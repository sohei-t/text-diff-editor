<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Diff Editor - Test Runner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      padding: 24px;
    }
    h1 { font-size: 20px; color: #f0f0f0; margin-bottom: 8px; }
    .summary {
      display: flex; gap: 16px; margin: 12px 0 20px; font-size: 14px;
      padding: 12px 16px; background: #16213e; border-radius: 8px;
    }
    .summary .pass { color: #4ade80; font-weight: 600; }
    .summary .fail { color: #f87171; font-weight: 600; }
    .summary .skip { color: #facc15; font-weight: 600; }
    .summary .total { color: #94a3b8; }
    .summary .rate { color: #60a5fa; font-weight: 600; font-size: 16px; }
    .progress-bar { height: 4px; background: #334155; border-radius: 2px; margin-bottom: 16px; overflow: hidden; }
    .progress-fill { height: 100%; background: #4ade80; transition: width 0.3s; }
    .suite { margin-bottom: 16px; }
    .suite-header {
      font-size: 14px; font-weight: 600; color: #94a3b8; padding: 6px 0;
      border-bottom: 1px solid #1e293b; margin-bottom: 4px; cursor: pointer;
    }
    .suite-header:hover { color: #cbd5e1; }
    .test {
      display: flex; align-items: flex-start; gap: 8px;
      padding: 4px 8px 4px 20px; font-size: 13px; border-radius: 4px;
    }
    .test:hover { background: rgba(255,255,255,0.03); }
    .test .icon { flex-shrink: 0; width: 16px; text-align: center; }
    .test.pass .icon { color: #4ade80; }
    .test.fail .icon { color: #f87171; }
    .test.skip .icon { color: #facc15; }
    .test .name { flex: 1; }
    .test .time { color: #64748b; font-size: 11px; font-family: monospace; }
    .test .error {
      margin-top: 4px; padding: 6px 10px; background: rgba(248,113,113,0.1);
      border-left: 2px solid #f87171; border-radius: 0 4px 4px 0;
      font-family: monospace; font-size: 11px; color: #fca5a5; white-space: pre-wrap;
      word-break: break-all;
    }
    #test-dom { position: absolute; left: -9999px; top: -9999px; }
    .running { animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    .filter-bar {
      display: flex; gap: 8px; margin-bottom: 12px;
    }
    .filter-btn {
      border: 1px solid #334155; background: transparent; color: #94a3b8;
      padding: 4px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;
    }
    .filter-btn.active { background: #334155; color: #f0f0f0; }
  </style>
</head>
<body>
  <h1 id="title" class="running">Text Diff Editor - Test Runner (Running...)</h1>
  <div class="summary" id="summary">
    <span class="total">Total: <span id="count-total">0</span></span>
    <span class="pass">Passed: <span id="count-pass">0</span></span>
    <span class="fail">Failed: <span id="count-fail">0</span></span>
    <span class="skip">Skipped: <span id="count-skip">0</span></span>
    <span class="rate">Rate: <span id="count-rate">-</span></span>
  </div>
  <div class="progress-bar"><div class="progress-fill" id="progress" style="width:0%"></div></div>
  <div class="filter-bar">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="fail">Failed</button>
    <button class="filter-btn" data-filter="pass">Passed</button>
  </div>
  <div id="results"></div>

  <!-- Hidden DOM for tests that need DOM elements -->
  <div id="test-dom">
    <div id="test-toolbar"></div>
    <div id="test-status-bar"></div>
    <div id="test-search-bar"></div>
    <div id="test-toast-container"></div>
    <div id="test-editor-container">
      <div id="test-panel-left" class="editor-panel">
        <div id="test-line-numbers-left" class="line-numbers"></div>
        <textarea id="test-editor-left" class="editor-textarea"></textarea>
      </div>
      <div id="test-splitter"></div>
      <div id="test-panel-right" class="editor-panel">
        <div id="test-line-numbers-right" class="line-numbers"></div>
        <textarea id="test-editor-right" class="editor-textarea"></textarea>
      </div>
    </div>
  </div>

  <!-- Load application source files -->
  <script src="js/core.js"></script>
  <script src="js/editor.js"></script>
  <script src="js/viewport.js"></script>
  <script src="js/files.js"></script>
  <script src="js/split-diff.js"></script>
  <script src="js/search.js"></script>
  <script src="js/ui.js"></script>

  <script>
  // ============================================================
  // Lightweight Test Framework
  // ============================================================
  (function() {
    'use strict';

    const suites = [];
    let currentSuite = null;

    window.describe = function(name, fn) {
      const suite = { name, tests: [], beforeEachFn: null, afterEachFn: null };
      const prevSuite = currentSuite;
      currentSuite = suite;
      fn();
      currentSuite = prevSuite;
      suites.push(suite);
    };

    window.it = function(name, fn) {
      if (currentSuite) {
        // Wrap done()-style callbacks in a Promise
        let wrappedFn = fn;
        if (fn.length > 0) {
          wrappedFn = function() {
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => reject(new Error('Test timed out (5s)')), 5000);
              fn(function done(err) {
                clearTimeout(timeout);
                if (err) reject(err);
                else resolve();
              });
            });
          };
        }
        currentSuite.tests.push({ name, fn: wrappedFn, status: 'pending', error: null, time: 0 });
      }
    };

    window.beforeEach = function(fn) {
      if (currentSuite) currentSuite.beforeEachFn = fn;
    };

    window.afterEach = function(fn) {
      if (currentSuite) currentSuite.afterEachFn = fn;
    };

    window.assert = {
      equal(actual, expected, msg) {
        if (actual !== expected) {
          throw new Error(msg || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
        }
      },
      notEqual(actual, expected, msg) {
        if (actual === expected) {
          throw new Error(msg || `Expected value to differ from ${JSON.stringify(expected)}`);
        }
      },
      deepEqual(actual, expected, msg) {
        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
          throw new Error(msg || `Deep equal failed:\n  actual: ${JSON.stringify(actual)}\n  expected: ${JSON.stringify(expected)}`);
        }
      },
      ok(value, msg) {
        if (!value) throw new Error(msg || `Expected truthy value, got ${JSON.stringify(value)}`);
      },
      notOk(value, msg) {
        if (value) throw new Error(msg || `Expected falsy value, got ${JSON.stringify(value)}`);
      },
      throws(fn, msg) {
        let threw = false;
        try { fn(); } catch(e) { threw = true; }
        if (!threw) throw new Error(msg || 'Expected function to throw');
      },
      doesNotThrow(fn, msg) {
        try { fn(); } catch(e) { throw new Error(msg || `Expected no throw, but got: ${e.message}`); }
      },
      approximately(actual, expected, tolerance, msg) {
        if (Math.abs(actual - expected) > tolerance) {
          throw new Error(msg || `Expected ${actual} to be within ${tolerance} of ${expected}`);
        }
      },
      greaterThan(actual, expected, msg) {
        if (actual <= expected) throw new Error(msg || `Expected ${actual} > ${expected}`);
      },
      lessThan(actual, expected, msg) {
        if (actual >= expected) throw new Error(msg || `Expected ${actual} < ${expected}`);
      },
      includes(arr, item, msg) {
        if (!arr.includes(item)) throw new Error(msg || `Expected array to include ${JSON.stringify(item)}`);
      },
      instanceOf(obj, cls, msg) {
        if (!(obj instanceof cls)) throw new Error(msg || `Expected instance of ${cls.name}`);
      }
    };

    // ============================================================
    // Test Execution
    // ============================================================
    async function runAllTests() {
      const results = { total: 0, pass: 0, fail: 0, skip: 0 };
      const resultsEl = document.getElementById('results');
      resultsEl.innerHTML = '';

      for (const suite of suites) {
        const suiteEl = document.createElement('div');
        suiteEl.className = 'suite';
        const header = document.createElement('div');
        header.className = 'suite-header';
        header.textContent = suite.name;
        suiteEl.appendChild(header);

        for (const test of suite.tests) {
          results.total++;
          const start = performance.now();

          try {
            // Reset EventBus for isolation
            if (window.EventBus && window.EventBus.destroy) {
              window.EventBus.destroy();
              window.EventBus = new EventBus();
            }

            if (suite.beforeEachFn) await suite.beforeEachFn();
            await test.fn();
            if (suite.afterEachFn) await suite.afterEachFn();

            test.status = 'pass';
            test.time = performance.now() - start;
            results.pass++;
          } catch (err) {
            test.status = 'fail';
            test.error = err.message || String(err);
            test.time = performance.now() - start;
            results.fail++;

            if (suite.afterEachFn) {
              try { await suite.afterEachFn(); } catch(e) {}
            }
          }

          // Render test result
          const testEl = document.createElement('div');
          testEl.className = `test ${test.status}`;
          testEl.dataset.status = test.status;

          const icon = test.status === 'pass' ? '\u2713' : test.status === 'fail' ? '\u2717' : '\u25CB';
          testEl.innerHTML = `
            <span class="icon">${icon}</span>
            <span class="name">${test.name}</span>
            <span class="time">${test.time.toFixed(1)}ms</span>
          `;

          if (test.error) {
            const errorEl = document.createElement('div');
            errorEl.className = 'error';
            errorEl.textContent = test.error;
            testEl.appendChild(errorEl);
          }

          suiteEl.appendChild(testEl);

          // Update progress
          const pct = Math.round((results.total / getTotalTestCount()) * 100);
          document.getElementById('progress').style.width = pct + '%';
          updateSummary(results);
        }

        resultsEl.appendChild(suiteEl);
      }

      // Final update
      updateSummary(results);
      document.getElementById('title').textContent = `Text Diff Editor - Test Runner (${results.pass}/${results.total} passed)`;
      document.getElementById('title').classList.remove('running');

      if (results.fail > 0) {
        document.getElementById('progress').style.background = '#f87171';
      }

      return results;
    }

    function getTotalTestCount() {
      let count = 0;
      suites.forEach(s => count += s.tests.length);
      return count || 1;
    }

    function updateSummary(r) {
      document.getElementById('count-total').textContent = r.total;
      document.getElementById('count-pass').textContent = r.pass;
      document.getElementById('count-fail').textContent = r.fail;
      document.getElementById('count-skip').textContent = r.skip;
      const rate = r.total > 0 ? Math.round((r.pass / r.total) * 100) : 0;
      document.getElementById('count-rate').textContent = rate + '%';
    }

    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const filter = btn.dataset.filter;
        document.querySelectorAll('.test').forEach(t => {
          if (filter === 'all') { t.style.display = ''; }
          else { t.style.display = t.dataset.status === filter ? '' : 'none'; }
        });
      });
    });

    window._runAllTests = runAllTests;
  })();

  // ============================================================
  // TEST SUITES
  // ============================================================

  // ---- EventBus Tests (6 cases) ----
  describe('EventBus', () => {
    it('TC-EB-001: should call registered listener when event is emitted', () => {
      const bus = new EventBus();
      let received = null;
      bus.on('test', (data) => { received = data; });
      bus.emit('test', { value: 42 });
      assert.deepEqual(received, { value: 42 });
    });

    it('TC-EB-002: should call all registered listeners for the same event', () => {
      const bus = new EventBus();
      let count = 0;
      bus.on('test', () => count++);
      bus.on('test', () => count++);
      bus.on('test', () => count++);
      bus.emit('test', {});
      assert.equal(count, 3);
    });

    it('TC-EB-003: should not call removed listener', () => {
      const bus = new EventBus();
      let called = false;
      const cb = () => { called = true; };
      bus.on('test', cb);
      bus.off('test', cb);
      bus.emit('test', {});
      assert.notOk(called);
    });

    it('TC-EB-004: should call once listener only once', () => {
      const bus = new EventBus();
      let count = 0;
      bus.once('test', () => count++);
      bus.emit('test', {});
      bus.emit('test', {});
      assert.equal(count, 1);
    });

    it('TC-EB-005: should not throw when emitting event with no listeners', () => {
      const bus = new EventBus();
      assert.doesNotThrow(() => bus.emit('nonexistent', {}));
    });

    it('TC-EB-006: should not call any listeners after destroy', () => {
      const bus = new EventBus();
      let called = false;
      bus.on('test', () => { called = true; });
      bus.destroy();
      bus.emit('test', {});
      assert.notOk(called);
    });
  });

  // ---- EditorManager Tests (10 cases) ----
  describe('EditorManager', () => {
    let editor, textarea, lineNums;

    beforeEach(() => {
      textarea = document.getElementById('test-editor-left');
      lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      editor = new EditorManager(textarea, lineNums, 'left');
    });

    afterEach(() => {
      if (editor) editor.destroy();
    });

    it('TC-EM-001: should set and get text content', () => {
      editor.setText('Hello World');
      assert.equal(editor.getText(), 'Hello World');
    });

    it('TC-EM-002: should handle empty text correctly', () => {
      editor.setText('some text');
      editor.setText('');
      assert.equal(editor.getText(), '');
      assert.equal(editor.getLineCount(), 1);
    });

    it('TC-EM-003: should return correct cursor position', () => {
      editor.setText('line1\nline2\nline3');
      // Set cursor to position 8 (start of 'ne2' on line 2)
      textarea.selectionStart = 8;
      textarea.selectionEnd = 8;
      const pos = editor.getCursorPosition();
      assert.equal(pos.line, 2);
      assert.equal(pos.column, 3);
    });

    it('TC-EM-004: should set cursor to specified position', () => {
      editor.setText('line1\nline2');
      editor.setCursorPosition(2, 1);
      const pos = editor.getCursorPosition();
      assert.equal(pos.line, 2);
      assert.equal(pos.column, 1);
    });

    it('TC-EM-005: should return correct line count', () => {
      editor.setText('a\nb\nc\nd');
      assert.equal(editor.getLineCount(), 4);
    });

    it('TC-EM-006: should insert text at specified position', () => {
      editor.setText('Hello World');
      editor.insertText(5, ' Beautiful');
      assert.equal(editor.getText(), 'Hello Beautiful World');
    });

    it('TC-EM-007: should replace text in specified range', () => {
      editor.setText('Hello World');
      editor.replaceRange(0, 5, 'Goodbye');
      assert.equal(editor.getText(), 'Goodbye World');
    });

    it('TC-EM-008: should emit editor:change on setText', () => {
      let emittedContent = null;
      EventBus.on('editor:change', (data) => { emittedContent = data.content; });
      editor.setText('Test content');
      assert.equal(emittedContent, 'Test content');
    });

    it('TC-EM-009: should update line numbers when text changes', () => {
      editor.setText('a\nb\nc');
      editor.updateLineNumbers();
      assert.equal(lineNums.children.length, 3);
    });

    it('TC-EM-010: should apply font size to textarea', () => {
      editor.setFontSize(24);
      assert.equal(textarea.style.fontSize, '24px');
    });
  });

  // ---- ZoomController Tests (8 cases) ----
  describe('ZoomController', () => {
    let zoom, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      container.style.transform = '';
      window.EventBus = new EventBus();
      zoom = new ZoomController(container, { baseFontSize: 18, minZoom: 0.5, maxZoom: 4.0 });
    });

    afterEach(() => {
      if (zoom) zoom.destroy();
    });

    it('TC-ZC-001: should initialize with zoom level 1.0', () => {
      assert.equal(zoom.getZoom(), 1.0);
    });

    it('TC-ZC-002: should increase zoom level by 0.25 on zoomIn()', () => {
      zoom.zoomIn();
      assert.equal(zoom.getZoom(), 1.25);
    });

    it('TC-ZC-003: should decrease zoom level by 0.25 on zoomOut()', () => {
      zoom.zoomOut();
      assert.equal(zoom.getZoom(), 0.75);
    });

    it('TC-ZC-004: should not exceed max zoom level (4.0)', () => {
      zoom.setZoom(3.9);
      zoom.zoomIn();
      assert.equal(zoom.getZoom(), 4.0);
    });

    it('TC-ZC-005: should not go below min zoom level (0.5)', () => {
      zoom.setZoom(0.6);
      zoom.zoomOut();
      assert.equal(zoom.getZoom(), 0.5);
    });

    it('TC-ZC-006: should apply CSS transform scale to container', () => {
      zoom.setZoom(1.5);
      assert.ok(container.style.transform.includes('scale(1.5)'));
    });

    it('TC-ZC-007: should reset zoom to 1.0 on resetZoom()', () => {
      zoom.setZoom(2.0);
      zoom.resetZoom();
      assert.equal(zoom.getZoom(), 1.0);
    });

    it('TC-ZC-008: should emit zoom:change event on zoom', () => {
      let emittedLevel = null;
      EventBus.on('zoom:change', (data) => { emittedLevel = data.level; });
      zoom.setZoom(1.5);
      assert.equal(emittedLevel, 1.5);
    });
  });

  // ---- PanController Tests (6 cases) ----
  describe('PanController', () => {
    let pan, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      pan = new PanController(container);
    });

    afterEach(() => {
      if (pan) pan.destroy();
    });

    it('TC-PC-001: should start panning on Alt+mousedown', () => {
      const event = new MouseEvent('mousedown', { altKey: true, bubbles: true });
      container.dispatchEvent(event);
      assert.ok(pan.isPanning());
    });

    it('TC-PC-002: should not pan without Alt key', () => {
      const event = new MouseEvent('mousedown', { altKey: false, bubbles: true });
      container.dispatchEvent(event);
      assert.notOk(pan.isPanning());
    });

    it('TC-PC-003: should stop panning on mouseup', () => {
      const down = new MouseEvent('mousedown', { altKey: true, bubbles: true });
      container.dispatchEvent(down);
      assert.ok(pan.isPanning());
      const up = new MouseEvent('mouseup', { bubbles: true });
      document.dispatchEvent(up);
      assert.notOk(pan.isPanning());
    });

    it('TC-PC-004: should emit pan:start on pan begin', () => {
      let started = false;
      EventBus.on('pan:start', () => { started = true; });
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      assert.ok(started);
    });

    it('TC-PC-005: should be disableable', () => {
      pan.disable();
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      assert.notOk(pan.isPanning());
    });

    it('TC-PC-006: should re-enable after disable', () => {
      pan.disable();
      pan.enable();
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      assert.ok(pan.isPanning());
    });
  });

  // ---- DiffEngine Tests (10 cases) ----
  describe('DiffEngine', () => {
    let diff;

    beforeEach(() => {
      diff = new DiffEngine();
    });

    it('TC-DE-001: should return equal for identical texts', () => {
      const result = diff.computeLineDiff('hello\nworld', 'hello\nworld');
      assert.equal(result.changes.length, 2);
      assert.ok(result.changes.every(c => c.type === 'equal'));
    });

    it('TC-DE-002: should detect added lines', () => {
      const result = diff.computeLineDiff('line1', 'line1\nline2');
      const adds = result.changes.filter(c => c.type === 'add');
      assert.equal(adds.length, 1);
      assert.equal(adds[0].contentRight, 'line2');
    });

    it('TC-DE-003: should detect deleted lines', () => {
      const result = diff.computeLineDiff('line1\nline2', 'line1');
      const dels = result.changes.filter(c => c.type === 'delete');
      assert.equal(dels.length, 1);
      assert.equal(dels[0].contentLeft, 'line2');
    });

    it('TC-DE-004: should detect modified lines', () => {
      const result = diff.computeLineDiff('hello world', 'hello earth');
      const mods = result.changes.filter(c => c.type === 'modify');
      assert.equal(mods.length, 1);
    });

    it('TC-DE-005: should compute inline diffs for modified lines', () => {
      const result = diff.computeLineDiff('hello world', 'hello earth');
      const mod = result.changes.find(c => c.type === 'modify');
      assert.ok(mod.inlineDiffs.length > 0);
    });

    it('TC-DE-006: should handle empty texts', () => {
      const result = diff.computeLineDiff('', '');
      assert.ok(result.changes.length >= 0);
    });

    it('TC-DE-007: should compute correct stats', () => {
      const result = diff.computeLineDiff('a\nb\nc', 'a\nB\nc\nd');
      assert.equal(result.stats.unchanged, 2); // a, c
      assert.ok(result.stats.modified >= 0 || result.stats.added >= 0 || result.stats.deleted >= 0);
    });

    it('TC-DE-008: should normalize CRLF line endings', () => {
      const result = diff.computeLineDiff('a\r\nb', 'a\nb');
      assert.ok(result.changes.every(c => c.type === 'equal'));
    });

    it('TC-DE-009: should handle large text (performance)', () => {
      const linesA = Array.from({ length: 1000 }, (_, i) => `line ${i}`).join('\n');
      const linesB = Array.from({ length: 1000 }, (_, i) => i === 500 ? `changed line ${i}` : `line ${i}`).join('\n');
      const start = performance.now();
      const result = diff.computeLineDiff(linesA, linesB);
      const elapsed = performance.now() - start;
      assert.ok(result.changes.length > 0);
      // Should complete in reasonable time (< 2000ms for 1000 lines)
      assert.ok(elapsed < 2000, `Diff took ${elapsed}ms, expected < 2000ms`);
    });

    it('TC-DE-010: should compute inline diff for character-level changes', () => {
      const inlineDiffs = diff.computeInlineDiff('abcdef', 'abXYef');
      assert.ok(inlineDiffs.length > 0);
      const hasDelete = inlineDiffs.some(d => d.type === 'delete');
      const hasAdd = inlineDiffs.some(d => d.type === 'add');
      assert.ok(hasDelete || hasAdd, 'Should detect character differences');
    });
  });

  // ---- FileManager Tests (6 cases) ----
  describe('FileManager', () => {
    let fm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      fm = new FileManager();
    });

    it('TC-FM-001: should initialize with Untitled files', () => {
      assert.equal(fm.getFileName('left'), 'Untitled');
      assert.equal(fm.getFileName('right'), 'Untitled');
    });

    it('TC-FM-002: should create new file with empty content', () => {
      let emittedPanelId = null;
      EventBus.on('file:new', (data) => { emittedPanelId = data.panelId; });
      fm.createNew('left');
      assert.equal(emittedPanelId, 'left');
      assert.equal(fm.getFileName('left'), 'Untitled');
    });

    it('TC-FM-003: should detect native File System API support', () => {
      const supported = fm.isNativeSupported();
      assert.equal(typeof supported, 'boolean');
    });

    it('TC-FM-004: should handle drop events', async () => {
      let emitted = false;
      EventBus.on('file:open', () => { emitted = true; });
      const file = new File(['test content'], 'test.txt', { type: 'text/plain' });
      await fm.handleDrop('left', file);
      assert.ok(emitted);
    });

    it('TC-FM-005: should store file state per panel', () => {
      fm.files.left = { name: 'left.txt', handle: null, content: 'left content' };
      fm.files.right = { name: 'right.txt', handle: null, content: 'right content' };
      assert.equal(fm.getFileName('left'), 'left.txt');
      assert.equal(fm.getFileName('right'), 'right.txt');
    });

    it('TC-FM-006: should warn about binary file drops', async () => {
      let toastType = null;
      EventBus.on('toast:show', (data) => { toastType = data.type; });
      const file = new File(['binary'], 'image.png', { type: 'image/png' });
      await fm.handleDrop('left', file);
      assert.equal(toastType, 'warning');
    });
  });

  // ---- SplitView Tests (6 cases) ----
  describe('SplitView', () => {
    let sv, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();

      // Set up panel IDs expected by SplitView
      const origLeft = document.getElementById('panel-left');
      const origRight = document.getElementById('panel-right');
      const origSplitter = document.getElementById('splitter');

      // Use test elements but with correct IDs temporarily
      // SplitView looks for getElementById so we just test the logic
      sv = new SplitView(container);
    });

    it('TC-SV-001: should not be split by default', () => {
      assert.notOk(sv.isSplit());
    });

    it('TC-SV-002: should toggle split mode', () => {
      sv.setSplit(true);
      assert.ok(sv.isSplit());
      sv.setSplit(false);
      assert.notOk(sv.isSplit());
    });

    it('TC-SV-003: should emit split:toggle event', () => {
      let emitted = null;
      EventBus.on('split:toggle', (data) => { emitted = data; });
      sv.setSplit(true);
      assert.ok(emitted);
      assert.equal(emitted.enabled, true);
    });

    it('TC-SV-004: should clamp split ratio between 0.2 and 0.8', () => {
      sv.setSplitRatio(0.1);
      assert.equal(sv.getSplitRatio(), 0.2);
      sv.setSplitRatio(0.9);
      assert.equal(sv.getSplitRatio(), 0.8);
    });

    it('TC-SV-005: should set sync scroll state', () => {
      sv.setSyncScroll(false);
      assert.equal(sv.syncScroll, false);
      sv.setSyncScroll(true);
      assert.equal(sv.syncScroll, true);
    });

    it('TC-SV-006: should have a DiffEngine instance', () => {
      assert.ok(sv.diffEngine instanceof DiffEngine);
    });
  });

  // ---- SearchManager Tests (8 cases) ----
  describe('SearchManager', () => {
    let sm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      // SearchManager looks for specific DOM IDs, so we need them
      // We test the core logic
      sm = new SearchManager();
    });

    it('TC-SM-001: should initialize with empty state', () => {
      assert.equal(sm.query, '');
      assert.equal(sm.matches.length, 0);
      assert.equal(sm.currentIndex, -1);
    });

    it('TC-SM-002: should find matches in text', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello world hello';
      const result = sm.find('hello');
      assert.equal(result.total, 2);
    });

    it('TC-SM-003: should support case sensitive search', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'Hello hello HELLO';
      const result = sm.find('hello', { caseSensitive: true });
      assert.equal(result.total, 1);
    });

    it('TC-SM-004: should support regex search', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'cat bat sat';
      const result = sm.find('[cbs]at', { useRegex: true });
      assert.equal(result.total, 3);
    });

    it('TC-SM-005: should navigate to next match', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      const next = sm.findNext();
      assert.ok(next);
      assert.equal(next.index, 1);
    });

    it('TC-SM-006: should navigate to previous match', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      const prev = sm.findPrevious();
      assert.ok(prev);
    });

    it('TC-SM-007: should replace current match', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello world';
      sm.find('hello');
      sm.replace('goodbye');
      assert.equal(sm.activeEditor.value, 'goodbye world');
    });

    it('TC-SM-008: should replace all matches', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      const count = sm.replaceAll('ccc');
      assert.equal(count, 2);
      assert.equal(sm.activeEditor.value, 'ccc bbb ccc');
    });
  });

  // ---- ThemeManager Tests (5 cases) ----
  describe('ThemeManager', () => {
    let tm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      tm = new ThemeManager();
    });

    afterEach(() => {
      tm.destroy();
      document.documentElement.setAttribute('data-theme', 'light');
    });

    it('TC-TM-001: should default to light theme', () => {
      localStorage.removeItem('textDiffEditor_theme');
      const tm2 = new ThemeManager();
      assert.equal(tm2.getTheme(), 'light');
      tm2.destroy();
    });

    it('TC-TM-002: should toggle through themes', () => {
      tm.setTheme('light');
      tm.toggleTheme();
      assert.equal(tm.getTheme(), 'dark');
      tm.toggleTheme();
      assert.equal(tm.getTheme(), 'high-contrast');
      tm.toggleTheme();
      assert.equal(tm.getTheme(), 'light');
    });

    it('TC-TM-003: should apply data-theme attribute to html', () => {
      tm.setTheme('dark');
      assert.equal(document.documentElement.getAttribute('data-theme'), 'dark');
    });

    it('TC-TM-004: should emit theme:change event', () => {
      let emitted = null;
      EventBus.on('theme:change', (data) => { emitted = data; });
      tm.setTheme('high-contrast');
      assert.ok(emitted);
      assert.equal(emitted.theme, 'high-contrast');
    });

    it('TC-TM-005: should return available themes', () => {
      const themes = tm.getAvailableThemes();
      assert.equal(themes.length, 3);
      assert.includes(themes, 'light');
      assert.includes(themes, 'dark');
      assert.includes(themes, 'high-contrast');
    });
  });

  // ---- AutoSave Tests (4 cases) ----
  describe('AutoSave', () => {
    let as;

    beforeEach(() => {
      window.EventBus = new EventBus();
      as = new AutoSave();
    });

    afterEach(() => {
      as.destroy();
    });

    it('TC-AS-001: should not be enabled by default', () => {
      assert.notOk(as.isEnabled());
    });

    it('TC-AS-002: should enable with start()', () => {
      as.start(5000);
      assert.ok(as.isEnabled());
    });

    it('TC-AS-003: should disable with stop()', () => {
      as.start(5000);
      as.stop();
      assert.notOk(as.isEnabled());
    });

    it('TC-AS-004: should emit file:save when modified and timer fires', (done) => {
      let saved = false;
      EventBus.on('file:save', () => { saved = true; });
      as.start(50); // 50ms interval for fast test
      as._modified = true;
      setTimeout(() => {
        as.stop();
        assert.ok(saved, 'file:save should have been emitted');
        done();
      }, 100);
    });
  });

  // ---- Utils Tests (6 cases) ----
  describe('Utils', () => {
    it('TC-UT-001: clamp should constrain value to range', () => {
      assert.equal(Utils.clamp(5, 0, 10), 5);
      assert.equal(Utils.clamp(-1, 0, 10), 0);
      assert.equal(Utils.clamp(15, 0, 10), 10);
    });

    it('TC-UT-002: escapeHtml should escape special characters', () => {
      assert.equal(Utils.escapeHtml('<script>alert("xss")</script>'), '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;');
    });

    it('TC-UT-003: escapeRegex should escape regex special characters', () => {
      assert.equal(Utils.escapeRegex('a.b*c'), 'a\\.b\\*c');
    });

    it('TC-UT-004: formatFileSize should format bytes correctly', () => {
      assert.equal(Utils.formatFileSize(0), '0 B');
      assert.equal(Utils.formatFileSize(1024), '1 KB');
      assert.equal(Utils.formatFileSize(1048576), '1 MB');
    });

    it('TC-UT-005: debounce should delay execution', (done) => {
      let count = 0;
      const fn = Utils.debounce(() => count++, 30);
      fn(); fn(); fn();
      setTimeout(() => {
        assert.equal(count, 1);
        done();
      }, 80);
    });

    it('TC-UT-006: throttle should limit execution rate', (done) => {
      let count = 0;
      const fn = Utils.throttle(() => count++, 50);
      fn(); fn(); fn();
      assert.equal(count, 1);
      setTimeout(() => {
        fn();
        assert.equal(count, 2);
        done();
      }, 80);
    });
  });

  // ---- SettingsManager Tests (4 cases) ----
  describe('SettingsManager', () => {
    it('TC-SET-001: should have default settings', () => {
      const sm = new SettingsManager();
      assert.equal(sm.get('fontSize'), 18);
      assert.equal(sm.get('theme'), 'light');
    });

    it('TC-SET-002: should set and persist values', () => {
      const sm = new SettingsManager();
      sm.set('fontSize', 24);
      assert.equal(sm.get('fontSize'), 24);
      // Check localStorage
      const stored = JSON.parse(localStorage.getItem('textDiffEditor'));
      assert.equal(stored.fontSize, 24);
      // Reset
      sm.set('fontSize', 18);
    });

    it('TC-SET-003: should reset to defaults', () => {
      const sm = new SettingsManager();
      sm.set('fontSize', 36);
      sm.resetToDefaults();
      assert.equal(sm.get('fontSize'), 18);
    });

    it('TC-SET-004: should emit settings:change event', () => {
      window.EventBus = new EventBus();
      const sm = new SettingsManager();
      let emitted = null;
      EventBus.on('settings:change', (data) => { emitted = data; });
      sm.set('fontSize', 20);
      assert.ok(emitted);
      assert.equal(emitted.key, 'fontSize');
      assert.equal(emitted.value, 20);
      sm.set('fontSize', 18);
    });
  });

  // ---- Integration: Zoom + Editor Font (3 cases) ----
  describe('Integration: Zoom + Editor', () => {
    it('TC-INT-001: zoom commitZoom should update font sizes', () => {
      const container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      const zc = new ZoomController(container, { baseFontSize: 18 });
      zc.level = 2.0;
      zc.commitZoom();
      // commitZoom modifies all .editor-textarea elements font size
      const ta = document.querySelector('.editor-textarea');
      if (ta) {
        const size = parseFloat(ta.style.fontSize);
        assert.approximately(size, 36, 2, 'Font size should be ~36px at 2x zoom');
      }
      zc.level = 1.0;
      zc.commitZoom();
      zc.destroy();
    });

    it('TC-INT-002: zoom:change event should be received by toolbar', () => {
      window.EventBus = new EventBus();
      let received = null;
      EventBus.on('zoom:change', (data) => { received = data; });
      EventBus.emit('zoom:change', { level: 1.5 });
      assert.ok(received);
      assert.equal(received.level, 1.5);
    });

    it('TC-INT-003: editor:change should trigger diff:compute when split', () => {
      window.EventBus = new EventBus();
      let diffTriggered = false;
      EventBus.on('diff:compute', () => { diffTriggered = true; });
      // Simulate what app.js does: when split is active and editor changes
      // We directly test the event chain
      EventBus.emit('diff:compute', { textLeft: 'a', textRight: 'b' });
      assert.ok(diffTriggered);
    });
  });

  // ---- Integration: Diff + Split (3 cases) ----
  describe('Integration: Diff + Split', () => {
    it('TC-INT-004: diff engine should integrate with split view', () => {
      const engine = new DiffEngine();
      const result = engine.computeLineDiff('line1\nline2', 'line1\nmodified');
      assert.ok(result.changes.length > 0);
      assert.ok(result.stats);
    });

    it('TC-INT-005: diff:result should include stats', () => {
      window.EventBus = new EventBus();
      let stats = null;
      EventBus.on('diff:result', (data) => { stats = data.stats; });
      const engine = new DiffEngine();
      const result = engine.computeLineDiff('a\nb', 'a\nc');
      EventBus.emit('diff:result', result);
      assert.ok(stats);
      assert.equal(typeof stats.added, 'number');
      assert.equal(typeof stats.deleted, 'number');
    });

    it('TC-INT-006: diff navigation should emit navigated event', () => {
      window.EventBus = new EventBus();
      let navigated = false;
      EventBus.on('diff:navigated', () => { navigated = true; });
      EventBus.emit('diff:navigated', { change: {}, index: 0, total: 1, line: 1 });
      assert.ok(navigated);
    });
  });

  // ---- Integration: File + Editor (3 cases) ----
  describe('Integration: File + Editor', () => {
    it('TC-INT-007: file:open should be emittable and receivable', () => {
      window.EventBus = new EventBus();
      let received = null;
      EventBus.on('file:open', (data) => { received = data; });
      EventBus.emit('file:open', { panelId: 'left', name: 'test.txt', content: 'hello', handle: null });
      assert.ok(received);
      assert.equal(received.name, 'test.txt');
      assert.equal(received.content, 'hello');
    });

    it('TC-INT-008: file:modified event chain works', () => {
      window.EventBus = new EventBus();
      let modified = null;
      EventBus.on('file:modified', (data) => { modified = data; });
      EventBus.emit('file:modified', { panelId: 'left', modified: true });
      assert.ok(modified);
      assert.equal(modified.modified, true);
    });

    it('TC-INT-009: toast:show event chain works', () => {
      window.EventBus = new EventBus();
      let toastData = null;
      EventBus.on('toast:show', (data) => { toastData = data; });
      EventBus.emit('toast:show', { message: 'Test', type: 'info', duration: 1000 });
      assert.ok(toastData);
      assert.equal(toastData.message, 'Test');
    });
  });

  // ============================================================
  // ADDITIONAL CRITICAL PATH TESTS
  // ============================================================

  // ---- ZoomController: Wheel event test ----
  describe('ZoomController (Critical Path)', () => {
    it('TC-ZC-009: should respond to wheel event with ctrlKey', () => {
      const container = document.getElementById('test-editor-container');
      container.style.transform = '';
      window.EventBus = new EventBus();
      const zc = new ZoomController(container, { baseFontSize: 18, minZoom: 0.5, maxZoom: 4.0 });
      const initialZoom = zc.getZoom();

      // Simulate pinch zoom (ctrlKey + wheel)
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true,
        deltaY: -50,
        bubbles: true,
        cancelable: true
      });
      container.dispatchEvent(wheelEvent);

      assert.ok(zc.getZoom() > initialZoom, 'Zoom should increase on ctrl+wheel up');
      zc.destroy();
    });

    it('TC-ZC-010: should NOT zoom on wheel without ctrlKey', () => {
      const container = document.getElementById('test-editor-container');
      container.style.transform = '';
      window.EventBus = new EventBus();
      const zc = new ZoomController(container, { baseFontSize: 18 });
      const initialZoom = zc.getZoom();

      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: false,
        deltaY: -50,
        bubbles: true,
        cancelable: true
      });
      container.dispatchEvent(wheelEvent);

      assert.equal(zc.getZoom(), initialZoom, 'Zoom should not change without ctrlKey');
      zc.destroy();
    });
  });

  // ---- SearchManager: Edge cases ----
  describe('SearchManager (Edge Cases)', () => {
    let sm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      sm = new SearchManager();
    });

    it('TC-SM-009: should handle invalid regex gracefully', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'test content here';
      const result = sm.find('[invalid', { useRegex: true });
      assert.equal(result.total, 0);
    });

    it('TC-SM-010: should handle empty query', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'test content';
      const result = sm.find('');
      assert.equal(result.total, 0);
    });

    it('TC-SM-011: should wrap around when navigating past last match', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      sm.findNext(); // index 1
      const wrapped = sm.findNext(); // should wrap to index 0
      assert.equal(wrapped.index, 0);
    });
  });

  // ---- ThemeManager: Persistence ----
  describe('ThemeManager (Persistence)', () => {
    it('TC-TM-006: should persist theme to localStorage', () => {
      window.EventBus = new EventBus();
      const tm = new ThemeManager();
      tm.setTheme('high-contrast');
      const stored = localStorage.getItem('textDiffEditor_theme');
      assert.equal(stored, 'high-contrast');
      tm.setTheme('light');
      tm.destroy();
    });

    it('TC-TM-007: should restore theme from localStorage', () => {
      window.EventBus = new EventBus();
      localStorage.setItem('textDiffEditor_theme', 'dark');
      const tm = new ThemeManager();
      assert.equal(tm.getTheme(), 'dark');
      tm.setTheme('light');
      tm.destroy();
    });
  });

  // ---- AutoSave: Edge cases ----
  describe('AutoSave (Edge Cases)', () => {
    it('TC-AS-005: should not emit file:save when content is unmodified', (done) => {
      window.EventBus = new EventBus();
      const as = new AutoSave();
      let saved = false;
      EventBus.on('file:save', () => { saved = true; });
      as.start(50);
      // Do NOT set _modified = true
      setTimeout(() => {
        as.stop();
        assert.notOk(saved, 'file:save should NOT be emitted when unmodified');
        as.destroy();
        done();
      }, 100);
    });

    it('TC-AS-006: should clear timer on destroy', () => {
      window.EventBus = new EventBus();
      const as = new AutoSave();
      as.start(5000);
      assert.ok(as.isEnabled());
      as.destroy();
      assert.notOk(as.isEnabled());
    });
  });

  // ---- DiffEngine: Edge cases ----
  describe('DiffEngine (Edge Cases)', () => {
    let diff;

    beforeEach(() => {
      diff = new DiffEngine();
    });

    it('TC-DE-011: should handle one empty, one non-empty text', () => {
      const result = diff.computeLineDiff('', 'new line');
      const adds = result.changes.filter(c => c.type === 'add');
      assert.ok(adds.length > 0, 'Should detect added lines when comparing empty to non-empty');
    });

    it('TC-DE-012: should handle multi-line consecutive changes', () => {
      const result = diff.computeLineDiff('a\nb\nc\nd', 'a\nx\ny\nd');
      // b and c are changed to x and y
      const nonEqual = result.changes.filter(c => c.type !== 'equal');
      assert.ok(nonEqual.length > 0, 'Should detect changes in consecutive modified lines');
      // a and d should be equal
      const equals = result.changes.filter(c => c.type === 'equal');
      assert.ok(equals.length >= 2, 'Should have at least 2 equal lines (a and d)');
    });

    it('TC-DE-013: should handle special characters in text', () => {
      const textA = '<div class="test">&amp;</div>';
      const textB = '<div class="test">&amp;</div>';
      const result = diff.computeLineDiff(textA, textB);
      assert.ok(result.changes.every(c => c.type === 'equal'), 'Identical texts with special chars should be equal');
    });

    it('TC-DE-014: should compute async diff correctly', async () => {
      const textA = 'line1\nline2\nline3';
      const textB = 'line1\nmodified\nline3';
      const result = await diff.computeAsync(textA, textB);
      assert.ok(result.changes.length > 0);
      assert.ok(result.stats);
      const mods = result.changes.filter(c => c.type === 'modify');
      assert.ok(mods.length > 0, 'Should detect modifications in async mode');
    });
  });

  // ---- Editor: Undo/Redo ----
  describe('EditorManager (Undo/Redo)', () => {
    let editor, textarea, lineNums;

    beforeEach(() => {
      textarea = document.getElementById('test-editor-left');
      lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      editor = new EditorManager(textarea, lineNums, 'left');
    });

    afterEach(() => {
      if (editor) editor.destroy();
    });

    it('TC-EM-011: should support multi-line text correctly', () => {
      editor.setText('line1\nline2\nline3\nline4\nline5');
      assert.equal(editor.getLineCount(), 5);
      assert.equal(editor.getText().split('\n').length, 5);
    });

    it('TC-EM-012: should handle special characters in text', () => {
      const specialText = '<script>alert("xss")</script>\n&amp;\n\ttabs';
      editor.setText(specialText);
      assert.equal(editor.getText(), specialText);
    });
  });

  // ---- PanController: Reset test ----
  describe('PanController (Extended)', () => {
    it('TC-PC-007: should reset scroll position', () => {
      const container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      const pan = new PanController(container);
      const textarea = container.querySelector('.editor-textarea');
      if (textarea) {
        textarea.scrollLeft = 100;
        textarea.scrollTop = 100;
        pan.reset();
        assert.equal(textarea.scrollLeft, 0);
        assert.equal(textarea.scrollTop, 0);
      }
      pan.destroy();
    });

    it('TC-PC-008: should emit pan:end on mouseup', () => {
      const container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      const pan = new PanController(container);
      let ended = false;
      EventBus.on('pan:end', () => { ended = true; });

      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      document.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
      assert.ok(ended, 'pan:end should be emitted on mouseup after panning');
      pan.destroy();
    });
  });

  // ---- Integration: Zoom + Pan coordination ----
  describe('Integration: Zoom + Pan (Extended)', () => {
    it('TC-INT-010: zoom:change event should propagate zoom level', () => {
      window.EventBus = new EventBus();
      const container = document.getElementById('test-editor-container');
      const zc = new ZoomController(container, { baseFontSize: 18 });
      let receivedLevel = null;
      EventBus.on('zoom:change', (data) => { receivedLevel = data.level; });
      zc.zoomIn();
      assert.equal(receivedLevel, 1.25);
      zc.destroy();
    });

    it('TC-INT-011: zoom reset should emit both zoom:change and zoom:reset', () => {
      window.EventBus = new EventBus();
      const container = document.getElementById('test-editor-container');
      const zc = new ZoomController(container, { baseFontSize: 18 });
      let changeEmitted = false;
      let resetEmitted = false;
      EventBus.on('zoom:change', () => { changeEmitted = true; });
      EventBus.on('zoom:reset', () => { resetEmitted = true; });
      zc.setZoom(2.0);
      changeEmitted = false; // reset flag after setZoom
      zc.resetZoom();
      assert.ok(changeEmitted, 'zoom:change should be emitted on reset');
      assert.ok(resetEmitted, 'zoom:reset should be emitted on reset');
      zc.destroy();
    });
  });

  // ---- Integration: Diff + Split (Extended) ----
  describe('Integration: Diff + Split (Extended)', () => {
    it('TC-INT-012: diff:clear should be emitted when split is disabled', () => {
      window.EventBus = new EventBus();
      const container = document.getElementById('test-editor-container');
      const sv = new SplitView(container);
      let cleared = false;
      EventBus.on('diff:clear', () => { cleared = true; });
      sv.setSplit(true);
      sv.setSplit(false);
      assert.ok(cleared, 'diff:clear should be emitted when split mode is disabled');
    });

    it('TC-INT-013: split:resize event should be emitted on ratio change', () => {
      window.EventBus = new EventBus();
      const container = document.getElementById('test-editor-container');
      const sv = new SplitView(container);
      let resizeData = null;
      EventBus.on('split:resize', (data) => { resizeData = data; });
      sv.setSplitRatio(0.6);
      assert.ok(resizeData, 'split:resize should be emitted');
      assert.approximately(resizeData.ratio, 0.6, 0.01);
    });
  });

  // ---- Integration: File + Editor (Extended) ----
  describe('Integration: File + Editor (Extended)', () => {
    it('TC-INT-014: file:new should reset editor state', () => {
      window.EventBus = new EventBus();
      let newEvent = null;
      EventBus.on('file:new', (data) => { newEvent = data; });
      const fm = new FileManager();
      fm.createNew('left');
      assert.ok(newEvent, 'file:new should be emitted');
      assert.equal(newEvent.panelId, 'left');
      assert.equal(fm.getFileName('left'), 'Untitled');
    });

    it('TC-INT-015: file drop should read content and emit file:open', async () => {
      window.EventBus = new EventBus();
      let openEvent = null;
      EventBus.on('file:open', (data) => { openEvent = data; });
      const fm = new FileManager();
      const file = new File(['drop content here'], 'dropped.txt', { type: 'text/plain' });
      const result = await fm.handleDrop('right', file);
      assert.ok(result, 'handleDrop should return result');
      assert.equal(result.name, 'dropped.txt');
      assert.equal(result.content, 'drop content here');
      assert.ok(openEvent, 'file:open should be emitted');
      assert.equal(openEvent.panelId, 'right');
    });
  });

  // ---- SettingsManager: Extended ----
  describe('SettingsManager (Extended)', () => {
    it('TC-SET-005: should handle unknown settings keys gracefully', () => {
      const sm = new SettingsManager();
      const result = sm.get('nonExistentKey');
      assert.equal(result, undefined);
    });

    it('TC-SET-006: should preserve other settings when setting one', () => {
      const sm = new SettingsManager();
      sm.set('fontSize', 24);
      sm.set('theme', 'dark');
      assert.equal(sm.get('fontSize'), 24);
      assert.equal(sm.get('theme'), 'dark');
      sm.resetToDefaults();
    });

    it('TC-SET-007: should return all settings with getAll()', () => {
      const sm = new SettingsManager();
      const all = sm.getAll();
      assert.equal(typeof all, 'object');
      assert.equal(all.fontSize, 18);
      assert.equal(all.theme, 'light');
      assert.ok('wordWrap' in all);
      assert.ok('syncScroll' in all);
    });

    it('TC-SET-008: should return a copy from getAll (not reference)', () => {
      const sm = new SettingsManager();
      const all = sm.getAll();
      all.fontSize = 999;
      assert.equal(sm.get('fontSize'), 18, 'Mutating getAll result should not affect original');
    });

    it('TC-SET-009: should emit settings:reset on resetToDefaults', () => {
      window.EventBus = new EventBus();
      const sm = new SettingsManager();
      let emitted = null;
      EventBus.on('settings:reset', (data) => { emitted = data; });
      sm.set('fontSize', 36);
      sm.resetToDefaults();
      assert.ok(emitted, 'settings:reset should be emitted');
      assert.equal(emitted.fontSize, 18);
    });

    it('TC-SET-010: should have correct default values for all settings', () => {
      const sm = new SettingsManager();
      sm.resetToDefaults();
      assert.equal(sm.get('lineHeight'), 1.6);
      assert.equal(sm.get('wordWrap'), true);
      assert.equal(sm.get('showLineNumbers'), true);
      assert.equal(sm.get('highlightCurrentLine'), true);
      assert.equal(sm.get('autoSaveInterval'), 0);
      assert.equal(sm.get('splitRatio'), 0.5);
      assert.equal(sm.get('syncScroll'), true);
      assert.equal(sm.get('lastZoomLevel'), 1.0);
    });
  });

  // ============================================================
  // PHASE 4 COVERAGE IMPROVEMENT TESTS
  // ============================================================

  // ---- ZoomController: Comprehensive Coverage ----
  describe('ZoomController (Comprehensive Coverage)', () => {
    let zoom, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      container.style.transform = '';
      container.style.transformOrigin = '';
      window.EventBus = new EventBus();
      zoom = new ZoomController(container, { baseFontSize: 18, minZoom: 0.5, maxZoom: 4.0 });
    });

    afterEach(() => {
      if (zoom) zoom.destroy();
    });

    it('TC-ZC-011: should handle multiple zoomIn calls in sequence', () => {
      zoom.zoomIn(); // 1.25
      zoom.zoomIn(); // 1.50
      zoom.zoomIn(); // 1.75
      assert.equal(zoom.getZoom(), 1.75);
    });

    it('TC-ZC-012: should handle multiple zoomOut calls in sequence', () => {
      zoom.zoomOut(); // 0.75
      zoom.zoomOut(); // 0.50
      assert.equal(zoom.getZoom(), 0.5);
    });

    it('TC-ZC-013: should clamp zoomOut to minZoom', () => {
      zoom.setZoom(0.5);
      zoom.zoomOut();
      assert.equal(zoom.getZoom(), 0.5, 'Should not go below minZoom');
    });

    it('TC-ZC-014: should clamp zoomIn to maxZoom', () => {
      zoom.setZoom(4.0);
      zoom.zoomIn();
      assert.equal(zoom.getZoom(), 4.0, 'Should not go above maxZoom');
    });

    it('TC-ZC-015: should accept custom zoomStep option', () => {
      const zc2 = new ZoomController(container, { baseFontSize: 18, zoomStep: 0.01 });
      assert.equal(zc2.zoomStep, 0.01);
      zc2.destroy();
    });

    it('TC-ZC-016: setZoom with originX/originY should set transformOrigin', () => {
      // Set explicit bounding rect by having the container in DOM
      zoom.setZoom(1.5);
      assert.equal(zoom.getZoom(), 1.5);
      assert.ok(container.style.transform.includes('scale(1.5)'));
    });

    it('TC-ZC-017: commitZoom should reset transform to scale(1)', (done) => {
      zoom.setZoom(2.0);
      // commitZoom is delayed, call it directly
      zoom.commitZoom();
      // After commitZoom, transform should be scale(1)
      assert.ok(container.style.transform.includes('scale(1)'));
      done();
    });

    it('TC-ZC-018: commitZoom should set font size based on level', () => {
      zoom.level = 2.0;
      zoom.commitZoom();
      const ta = container.querySelector('.editor-textarea');
      if (ta) {
        const size = parseFloat(ta.style.fontSize);
        assert.approximately(size, 36, 2, 'Font size should be ~36px at 2x zoom');
      }
    });

    it('TC-ZC-019: zoom in from ctrl+wheel with negative deltaY', () => {
      const initialZoom = zoom.getZoom();
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true, deltaY: -100, bubbles: true, cancelable: true
      });
      container.dispatchEvent(wheelEvent);
      assert.ok(zoom.getZoom() > initialZoom, 'Zoom should increase');
    });

    it('TC-ZC-020: zoom out from ctrl+wheel with positive deltaY', () => {
      zoom.setZoom(2.0);
      const initialZoom = zoom.getZoom();
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true, deltaY: 100, bubbles: true, cancelable: true
      });
      container.dispatchEvent(wheelEvent);
      assert.ok(zoom.getZoom() < initialZoom, 'Zoom should decrease');
    });

    it('TC-ZC-021: should set will-change during zoom', () => {
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true, deltaY: -50, bubbles: true, cancelable: true
      });
      container.dispatchEvent(wheelEvent);
      assert.equal(container.style.willChange, 'transform');
    });

    it('TC-ZC-022: resetZoom should set transition for animation', () => {
      zoom.setZoom(2.0);
      zoom.resetZoom();
      assert.ok(container.style.transition.includes('transform'));
    });

    it('TC-ZC-023: should ignore wheel when not enabled', () => {
      zoom.enabled = false;
      const initialZoom = zoom.getZoom();
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true, deltaY: -100, bubbles: true, cancelable: true
      });
      container.dispatchEvent(wheelEvent);
      assert.equal(zoom.getZoom(), initialZoom, 'Zoom should not change when disabled');
    });

    it('TC-ZC-024: should ignore very small delta changes', () => {
      const initialZoom = zoom.getZoom();
      const wheelEvent = new WheelEvent('wheel', {
        ctrlKey: true, deltaY: 0, bubbles: true, cancelable: true
      });
      container.dispatchEvent(wheelEvent);
      assert.equal(zoom.getZoom(), initialZoom, 'Zoom should not change for zero delta');
    });
  });

  // ---- PanController: Comprehensive Coverage ----
  describe('PanController (Comprehensive Coverage)', () => {
    let pan, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      pan = new PanController(container);
    });

    afterEach(() => {
      if (pan) pan.destroy();
    });

    it('TC-PC-009: should set cursor to grabbing when panning starts', () => {
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      assert.equal(container.style.cursor, 'grabbing');
    });

    it('TC-PC-010: should reset cursor on mouseup', () => {
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      document.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
      assert.equal(container.style.cursor, '');
    });

    it('TC-PC-011: should emit pan:move during mousemove while panning', () => {
      let moveData = null;
      EventBus.on('pan:move', (data) => { moveData = data; });
      container.dispatchEvent(new MouseEvent('mousedown', {
        altKey: true, clientX: 100, clientY: 100, bubbles: true
      }));
      document.dispatchEvent(new MouseEvent('mousemove', {
        clientX: 150, clientY: 120, bubbles: true
      }));
      assert.ok(moveData, 'pan:move should be emitted');
      assert.equal(moveData.deltaX, 50);
      assert.equal(moveData.deltaY, 20);
      document.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
    });

    it('TC-PC-012: should not emit pan:move when not panning', () => {
      let moveData = null;
      EventBus.on('pan:move', (data) => { moveData = data; });
      document.dispatchEvent(new MouseEvent('mousemove', {
        clientX: 150, clientY: 120, bubbles: true
      }));
      assert.notOk(moveData, 'pan:move should not be emitted when not panning');
    });

    it('TC-PC-013: should track velocity during pan', () => {
      container.dispatchEvent(new MouseEvent('mousedown', {
        altKey: true, clientX: 100, clientY: 100, bubbles: true
      }));
      document.dispatchEvent(new MouseEvent('mousemove', {
        clientX: 130, clientY: 115, bubbles: true
      }));
      assert.equal(pan.velocityX, 30);
      assert.equal(pan.velocityY, 15);
      document.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
    });

    it('TC-PC-014: should accept custom friction option', () => {
      const pan2 = new PanController(container, { friction: 0.8 });
      assert.equal(pan2.friction, 0.8);
      pan2.destroy();
    });

    it('TC-PC-015: disable should stop active panning', () => {
      container.dispatchEvent(new MouseEvent('mousedown', { altKey: true, bubbles: true }));
      assert.ok(pan.isPanning());
      pan.disable();
      assert.notOk(pan.isPanning());
    });

    it('TC-PC-016: reset should zero out scroll position', () => {
      const textarea = container.querySelector('.editor-textarea');
      if (textarea) {
        textarea.scrollLeft = 200;
        textarea.scrollTop = 300;
        pan.reset();
        assert.equal(textarea.scrollLeft, 0);
        assert.equal(textarea.scrollTop, 0);
      }
    });
  });

  // ---- DiffEngine: Comprehensive Coverage ----
  describe('DiffEngine (Comprehensive Coverage)', () => {
    let diff;

    beforeEach(() => {
      diff = new DiffEngine();
    });

    it('TC-DE-015: should handle null input gracefully', () => {
      const result = diff.computeLineDiff(null, 'text');
      assert.ok(result.changes.length >= 0);
    });

    it('TC-DE-016: should handle undefined input gracefully', () => {
      const result = diff.computeLineDiff(undefined, undefined);
      assert.ok(result.changes.length >= 0);
    });

    it('TC-DE-017: should handle Unicode characters (Japanese)', () => {
      const result = diff.computeLineDiff('\n', '\n');
      const mods = result.changes.filter(c => c.type !== 'equal');
      assert.ok(mods.length > 0, 'Should detect change in Japanese text');
    });

    it('TC-DE-018: should handle emoji in text', () => {
      const result = diff.computeLineDiff('Hello ', 'Hello ');
      const mods = result.changes.filter(c => c.type !== 'equal');
      assert.ok(mods.length > 0, 'Should detect emoji change');
    });

    it('TC-DE-019: should handle very long single line (10000 chars)', () => {
      const longA = 'a'.repeat(10000);
      const longB = 'a'.repeat(5000) + 'b' + 'a'.repeat(4999);
      const result = diff.computeLineDiff(longA, longB);
      const mods = result.changes.filter(c => c.type !== 'equal');
      assert.ok(mods.length > 0, 'Should detect changes in long text');
    });

    it('TC-DE-020: should handle text with only newlines', () => {
      const result = diff.computeLineDiff('\n\n\n', '\n\n');
      assert.ok(result.changes.length > 0);
    });

    it('TC-DE-021: should handle consecutive delete operations', () => {
      const result = diff.computeLineDiff('a\nb\nc\nd\ne', 'a\ne');
      const dels = result.changes.filter(c => c.type === 'delete');
      assert.ok(dels.length >= 1, 'Should have at least one delete');
      assert.equal(result.stats.unchanged, 2); // a and e
    });

    it('TC-DE-022: should handle consecutive add operations', () => {
      const result = diff.computeLineDiff('a\ne', 'a\nb\nc\nd\ne');
      const adds = result.changes.filter(c => c.type === 'add');
      assert.ok(adds.length >= 1, 'Should have at least one add');
      assert.equal(result.stats.unchanged, 2); // a and e
    });

    it('TC-DE-023: computeStats should correctly count all types', () => {
      const changes = [
        { type: 'equal' }, { type: 'equal' },
        { type: 'add' },
        { type: 'delete' },
        { type: 'modify' }, { type: 'modify' }
      ];
      const stats = diff.computeStats(changes);
      assert.equal(stats.unchanged, 2);
      assert.equal(stats.added, 1);
      assert.equal(stats.deleted, 1);
      assert.equal(stats.modified, 2);
    });

    it('TC-DE-024: computeStats on empty changes array', () => {
      const stats = diff.computeStats([]);
      assert.equal(stats.unchanged, 0);
      assert.equal(stats.added, 0);
      assert.equal(stats.deleted, 0);
      assert.equal(stats.modified, 0);
    });

    it('TC-DE-025: computeInlineDiff for identical lines', () => {
      const result = diff.computeInlineDiff('same text', 'same text');
      assert.equal(result.length, 1);
      assert.equal(result[0].type, 'equal');
      assert.equal(result[0].text, 'same text');
    });

    it('TC-DE-026: computeInlineDiff for completely different lines', () => {
      const result = diff.computeInlineDiff('abc', 'xyz');
      const hasDelete = result.some(d => d.type === 'delete');
      const hasAdd = result.some(d => d.type === 'add');
      assert.ok(hasDelete || hasAdd, 'Should have differences');
    });

    it('TC-DE-027: computeInlineDiff for prefix change', () => {
      const result = diff.computeInlineDiff('Hello world', 'Goodbye world');
      assert.ok(result.length > 1, 'Should have multiple diff segments');
    });

    it('TC-DE-028: computeInlineDiff for suffix change', () => {
      const result = diff.computeInlineDiff('Hello world', 'Hello earth');
      assert.ok(result.length > 1, 'Should have multiple diff segments');
    });

    it('TC-DE-029: should handle mixed CRLF and LF', () => {
      const result = diff.computeLineDiff('a\r\nb\nc', 'a\nb\r\nc');
      assert.ok(result.changes.every(c => c.type === 'equal'), 'Should treat CRLF same as LF');
    });

    it('TC-DE-030: computeAsync should resolve with progress callback', async () => {
      let progressCalled = false;
      const result = await diff.computeAsync('line1\nline2', 'line1\nchanged', (p) => {
        progressCalled = true;
      });
      assert.ok(result.changes.length > 0);
      assert.ok(progressCalled, 'Progress callback should be called');
    });

    it('TC-DE-031: _normalizeAndSplit should handle empty string', () => {
      const result = diff._normalizeAndSplit('');
      assert.deepEqual(result, ['']);
    });

    it('TC-DE-032: _normalizeAndSplit should normalize \\r to \\n', () => {
      const result = diff._normalizeAndSplit('a\rb');
      assert.deepEqual(result, ['a', 'b']);
    });
  });

  // ---- FileManager: Comprehensive Coverage ----
  describe('FileManager (Comprehensive Coverage)', () => {
    let fm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      fm = new FileManager();
    });

    it('TC-FM-007: should handle text file drops correctly', async () => {
      const file = new File(['hello world'], 'doc.txt', { type: 'text/plain' });
      const result = await fm.handleDrop('left', file);
      assert.ok(result);
      assert.equal(result.name, 'doc.txt');
      assert.equal(result.content, 'hello world');
      assert.equal(fm.getFileName('left'), 'doc.txt');
    });

    it('TC-FM-008: should handle JSON file drops without warning', async () => {
      let toastType = null;
      EventBus.on('toast:show', (data) => { toastType = data.type; });
      const file = new File(['{"key":"value"}'], 'data.json', { type: 'application/json' });
      await fm.handleDrop('left', file);
      assert.notEqual(toastType, 'warning', 'JSON should not trigger binary warning');
    });

    it('TC-FM-009: should handle XML file drops without warning', async () => {
      let toastType = null;
      EventBus.on('toast:show', (data) => { toastType = data.type; });
      const file = new File(['<root/>'], 'data.xml', { type: 'application/xml' });
      await fm.handleDrop('left', file);
      assert.notEqual(toastType, 'warning');
    });

    it('TC-FM-010: should handle JavaScript file drops without warning', async () => {
      let toastType = null;
      EventBus.on('toast:show', (data) => { toastType = data.type; });
      const file = new File(['console.log("hi")'], 'app.js', { type: 'application/javascript' });
      await fm.handleDrop('left', file);
      assert.notEqual(toastType, 'warning');
    });

    it('TC-FM-011: createNew should reset file state', () => {
      fm.files.left = { name: 'test.txt', handle: {}, content: 'some content' };
      fm.createNew('left');
      assert.equal(fm.getFileName('left'), 'Untitled');
      assert.equal(fm.files.left.content, '');
      assert.equal(fm.files.left.handle, null);
    });

    it('TC-FM-012: createNew should emit file:new event', () => {
      let emitted = null;
      EventBus.on('file:new', (data) => { emitted = data; });
      fm.createNew('right');
      assert.ok(emitted);
      assert.equal(emitted.panelId, 'right');
    });

    it('TC-FM-013: isNativeSupported should return boolean', () => {
      const result = fm.isNativeSupported();
      assert.equal(typeof result, 'boolean');
    });

    it('TC-FM-014: getFileName should return Untitled for missing panelId', () => {
      const name = fm.getFileName('nonexistent');
      assert.equal(name, 'Untitled');
    });

    it('TC-FM-015: destroy should not throw', () => {
      assert.doesNotThrow(() => fm.destroy());
    });

    it('TC-FM-016: _onSaveRequest should not throw', () => {
      assert.doesNotThrow(() => fm._onSaveRequest({ panelId: 'left' }));
    });

    it('TC-FM-017: _onSaveAsRequest should not throw', () => {
      assert.doesNotThrow(() => fm._onSaveAsRequest({ panelId: 'left' }));
    });
  });

  // ---- SearchManager: Comprehensive Coverage ----
  describe('SearchManager (Comprehensive Coverage)', () => {
    let sm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      sm = new SearchManager();
    });

    it('TC-SM-012: should emit search:result event on find', () => {
      let resultData = null;
      EventBus.on('search:result', (data) => { resultData = data; });
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'abc def abc';
      sm.find('abc');
      assert.ok(resultData, 'search:result should be emitted');
      assert.equal(resultData.total, 2);
    });

    it('TC-SM-013: findNext should emit search:navigate event', () => {
      let navData = null;
      EventBus.on('search:navigate', (data) => { navData = data; });
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      sm.findNext();
      assert.ok(navData);
      assert.equal(navData.direction, 'next');
    });

    it('TC-SM-014: findPrevious should emit search:navigate event', () => {
      let navData = null;
      EventBus.on('search:navigate', (data) => { navData = data; });
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa';
      sm.find('aaa');
      sm.findPrevious();
      assert.ok(navData);
      assert.equal(navData.direction, 'prev');
    });

    it('TC-SM-015: findPrevious should wrap around to last match', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'aaa bbb aaa ccc aaa';
      sm.find('aaa');
      // currentIndex starts at 0
      const result = sm.findPrevious(); // should wrap to last
      assert.equal(result.index, 2);
    });

    it('TC-SM-016: findNext and findPrevious should return null with no matches', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'no matches here';
      sm.find('zzz');
      assert.equal(sm.findNext(), null);
      assert.equal(sm.findPrevious(), null);
    });

    it('TC-SM-017: replace should dispatch input event on textarea', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello world';
      let inputFired = false;
      sm.activeEditor.addEventListener('input', () => { inputFired = true; }, { once: true });
      sm.find('hello');
      sm.replace('goodbye');
      assert.ok(inputFired, 'Input event should fire after replace');
    });

    it('TC-SM-018: replaceAll should return 0 when no matches', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello world';
      sm.find('zzz');
      const count = sm.replaceAll('yyy');
      assert.equal(count, 0);
    });

    it('TC-SM-019: replace should do nothing when no active editor', () => {
      sm.activeEditor = null;
      sm.find('test');
      assert.doesNotThrow(() => sm.replace('other'));
    });

    it('TC-SM-020: replace should do nothing when currentIndex is -1', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello world';
      sm.query = '';
      sm.matches = [];
      sm.currentIndex = -1;
      assert.doesNotThrow(() => sm.replace('other'));
    });

    it('TC-SM-021: case insensitive search should find all variations', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'Hello HELLO hello HeLLo';
      const result = sm.find('hello', { caseSensitive: false });
      assert.equal(result.total, 4);
    });

    it('TC-SM-022: regex search with groups', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'foo123 bar456 baz789';
      const result = sm.find('[a-z]+\\d+', { useRegex: true });
      assert.equal(result.total, 3);
    });

    it('TC-SM-023: close should reset state', () => {
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'hello hello';
      sm.find('hello');
      sm.close();
      assert.equal(sm.matches.length, 0);
      assert.equal(sm.currentIndex, -1);
      assert.notOk(sm.isOpen);
    });

    it('TC-SM-024: close should emit search:close event', () => {
      let closed = false;
      EventBus.on('search:close', () => { closed = true; });
      sm.close();
      assert.ok(closed);
    });

    it('TC-SM-025: destroy should not throw', () => {
      assert.doesNotThrow(() => sm.destroy());
    });
  });

  // ---- SplitView: Comprehensive Coverage ----
  describe('SplitView (Comprehensive Coverage)', () => {
    let sv, container;

    beforeEach(() => {
      container = document.getElementById('test-editor-container');
      window.EventBus = new EventBus();
      sv = new SplitView(container);
    });

    it('TC-SV-007: toggle() should flip split state', () => {
      assert.notOk(sv.isSplit());
      sv.toggle();
      assert.ok(sv.isSplit());
      sv.toggle();
      assert.notOk(sv.isSplit());
    });

    it('TC-SV-008: getPane should return correct panel reference', () => {
      const left = sv.getPane('left');
      const right = sv.getPane('right');
      assert.equal(left, sv.leftPanel);
      assert.equal(right, sv.rightPanel);
    });

    it('TC-SV-009: setSplit(true) should add split-mode class', () => {
      sv.setSplit(true);
      assert.ok(container.classList.contains('split-mode'));
      sv.setSplit(false);
      assert.notOk(container.classList.contains('split-mode'));
    });

    it('TC-SV-010: setSplit(false) should clear changes and emit diff:clear', () => {
      let cleared = false;
      EventBus.on('diff:clear', () => { cleared = true; });
      sv.setSplit(true);
      sv.changes = [{ type: 'add' }];
      sv.currentChangeIndex = 0;
      sv.setSplit(false);
      assert.ok(cleared);
      assert.equal(sv.changes.length, 0);
      assert.equal(sv.currentChangeIndex, -1);
    });

    it('TC-SV-011: setSplitRatio should enforce minimum 0.2', () => {
      sv.setSplitRatio(0.05);
      assert.equal(sv.getSplitRatio(), 0.2);
    });

    it('TC-SV-012: setSplitRatio should enforce maximum 0.8', () => {
      sv.setSplitRatio(0.95);
      assert.equal(sv.getSplitRatio(), 0.8);
    });

    it('TC-SV-013: setSplitRatio should accept valid ratio', () => {
      sv.setSplitRatio(0.3);
      assert.approximately(sv.getSplitRatio(), 0.3, 0.01);
    });

    it('TC-SV-014: should have default syncScroll enabled', () => {
      assert.equal(sv.syncScroll, true);
    });

    it('TC-SV-015: destroy should not throw', () => {
      assert.doesNotThrow(() => sv.destroy());
    });

    it('TC-SV-016: diff navigation via EventBus', () => {
      sv.setSplit(true);
      sv.changes = [
        { type: 'equal', lineLeft: 1, lineRight: 1 },
        { type: 'modify', lineLeft: 2, lineRight: 2 },
        { type: 'equal', lineLeft: 3, lineRight: 3 },
        { type: 'add', lineLeft: null, lineRight: 4 }
      ];
      let navData = null;
      EventBus.on('diff:navigated', (data) => { navData = data; });
      sv._navigateDiff('next');
      assert.ok(navData, 'diff:navigated should be emitted');
      assert.equal(navData.index, 0);
      assert.equal(navData.total, 2); // modify + add
    });

    it('TC-SV-017: diff navigate previous should wrap to last', () => {
      sv.changes = [
        { type: 'modify', lineLeft: 1, lineRight: 1 },
        { type: 'add', lineLeft: null, lineRight: 2 }
      ];
      sv.currentChangeIndex = 0;
      let navData = null;
      EventBus.on('diff:navigated', (data) => { navData = data; });
      sv._navigateDiff('prev');
      assert.ok(navData);
      assert.equal(navData.index, 1); // wrapped to last
    });

    it('TC-SV-018: diff navigate with no changes should do nothing', () => {
      sv.changes = [{ type: 'equal', lineLeft: 1, lineRight: 1 }]; // only equal
      let navData = null;
      EventBus.on('diff:navigated', (data) => { navData = data; });
      sv._navigateDiff('next');
      assert.notOk(navData, 'Should not navigate when no diff changes');
    });
  });

  // ---- EditorManager: Comprehensive Coverage ----
  describe('EditorManager (Comprehensive Coverage)', () => {
    let editor, textarea, lineNums;

    beforeEach(() => {
      textarea = document.getElementById('test-editor-left');
      lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      editor = new EditorManager(textarea, lineNums, 'left');
    });

    afterEach(() => {
      if (editor) editor.destroy();
    });

    it('TC-EM-013: undo should restore previous text', () => {
      editor.setText('first');
      editor.setText('second');
      editor.undo();
      assert.equal(editor.getText(), 'first');
    });

    it('TC-EM-014: redo should restore next text', () => {
      editor.setText('first');
      editor.setText('second');
      editor.undo();
      editor.redo();
      assert.equal(editor.getText(), 'second');
    });

    it('TC-EM-015: undo with empty stack should do nothing', () => {
      editor.setText('only');
      // undoStack has one entry from empty -> 'only'
      editor.undo();
      // Now undo again on empty stack
      const text = editor.getText();
      editor.undo(); // should not throw, text stays
      assert.equal(editor.getText(), text);
    });

    it('TC-EM-016: redo with empty stack should do nothing', () => {
      editor.setText('test');
      const text = editor.getText();
      editor.redo(); // empty redo stack
      assert.equal(editor.getText(), text);
    });

    it('TC-EM-017: getSelection should return selection data', () => {
      editor.setText('Hello World');
      textarea.selectionStart = 0;
      textarea.selectionEnd = 5;
      const sel = editor.getSelection();
      assert.equal(sel.start, 0);
      assert.equal(sel.end, 5);
      assert.equal(sel.text, 'Hello');
    });

    it('TC-EM-018: getLineCount with empty text should return 1', () => {
      editor.setText('');
      assert.equal(editor.getLineCount(), 1);
    });

    it('TC-EM-019: getLineCount with single line should return 1', () => {
      editor.setText('single line');
      assert.equal(editor.getLineCount(), 1);
    });

    it('TC-EM-020: getLineCount with multiple lines', () => {
      editor.setText('a\nb\nc\nd\ne\nf');
      assert.equal(editor.getLineCount(), 6);
    });

    it('TC-EM-021: setFontFamily should apply to textarea', () => {
      editor.setFontFamily('Arial, sans-serif');
      assert.equal(textarea.style.fontFamily, 'Arial, sans-serif');
    });

    it('TC-EM-022: setFontFamily should apply to line numbers', () => {
      editor.setFontFamily('Courier');
      assert.equal(lineNums.style.fontFamily, 'Courier');
    });

    it('TC-EM-023: setLineHeight should set based on fontSize', () => {
      textarea.style.fontSize = '20px';
      editor.setLineHeight(2.0);
      assert.equal(textarea.style.lineHeight, '40px');
    });

    it('TC-EM-024: setWordWrap true should set pre-wrap', () => {
      editor.setWordWrap(true);
      assert.equal(textarea.style.whiteSpace, 'pre-wrap');
      assert.equal(textarea.style.overflowX, 'hidden');
    });

    it('TC-EM-025: setWordWrap false should set pre', () => {
      editor.setWordWrap(false);
      assert.equal(textarea.style.whiteSpace, 'pre');
      assert.equal(textarea.style.overflowX, 'auto');
    });

    it('TC-EM-026: clearModified should reset modified flag', () => {
      editor.setText('something');
      editor.modified = true;
      let emittedModified = null;
      EventBus.on('file:modified', (data) => { emittedModified = data.modified; });
      editor.clearModified();
      assert.notOk(editor.modified);
      assert.equal(emittedModified, false);
    });

    it('TC-EM-027: scrollToLine should set scrollTop', () => {
      editor.setText(Array.from({ length: 100 }, (_, i) => `line ${i}`).join('\n'));
      editor.scrollToLine(50);
      // scrollTop should be set (exact value depends on line height)
      assert.ok(textarea.scrollTop >= 0);
    });

    it('TC-EM-028: setCursorPosition should handle beyond-bounds gracefully', () => {
      editor.setText('line1\nline2');
      assert.doesNotThrow(() => editor.setCursorPosition(100, 100));
    });

    it('TC-EM-029: focus should focus textarea', () => {
      editor.focus();
      assert.equal(document.activeElement, textarea);
    });

    it('TC-EM-030: replaceRange should update cursor position', () => {
      editor.setText('Hello World');
      editor.replaceRange(0, 5, 'Hi');
      assert.equal(editor.getText(), 'Hi World');
      assert.equal(textarea.selectionStart, 2);
      assert.equal(textarea.selectionEnd, 2);
    });

    it('TC-EM-031: should emit editor:focus event when focused', () => {
      let focusData = null;
      EventBus.on('editor:focus', (data) => { focusData = data; });
      textarea.dispatchEvent(new Event('focus'));
      assert.ok(focusData);
      assert.equal(focusData.panelId, 'left');
    });

    it('TC-EM-032: should handle text with special characters', () => {
      const text = 'Tab\there\n<html>&amp;\n"quotes"';
      editor.setText(text);
      assert.equal(editor.getText(), text);
    });
  });

  // ---- ThemeManager: Comprehensive Coverage ----
  describe('ThemeManager (Comprehensive Coverage)', () => {
    let tm;

    beforeEach(() => {
      window.EventBus = new EventBus();
      tm = new ThemeManager();
    });

    afterEach(() => {
      tm.destroy();
      document.documentElement.setAttribute('data-theme', 'light');
      localStorage.removeItem('textDiffEditor_theme');
    });

    it('TC-TM-008: should ignore invalid theme in setTheme', () => {
      tm.setTheme('dark');
      tm.setTheme('invalid-theme');
      assert.equal(tm.getTheme(), 'dark', 'Should stay on dark after invalid theme');
    });

    it('TC-TM-009: getAvailableThemes should return 3 themes', () => {
      const themes = tm.getAvailableThemes();
      assert.equal(themes.length, 3);
    });

    it('TC-TM-010: getAvailableThemes should return a copy', () => {
      const themes = tm.getAvailableThemes();
      themes.push('custom');
      assert.equal(tm.getAvailableThemes().length, 3);
    });

    it('TC-TM-011: getSystemTheme should return light or dark', () => {
      const systemTheme = tm.getSystemTheme();
      assert.ok(systemTheme === 'light' || systemTheme === 'dark');
    });

    it('TC-TM-012: setTheme should persist to localStorage', () => {
      tm.setTheme('dark');
      assert.equal(localStorage.getItem('textDiffEditor_theme'), 'dark');
    });

    it('TC-TM-013: constructor should load saved theme', () => {
      localStorage.setItem('textDiffEditor_theme', 'high-contrast');
      const tm2 = new ThemeManager();
      assert.equal(tm2.getTheme(), 'high-contrast');
      tm2.destroy();
    });

    it('TC-TM-014: destroy should not throw', () => {
      assert.doesNotThrow(() => tm.destroy());
    });

    it('TC-TM-015: setTheme should apply data-theme attribute', () => {
      tm.setTheme('high-contrast');
      assert.equal(document.documentElement.getAttribute('data-theme'), 'high-contrast');
    });
  });

  // ---- AutoSave: Comprehensive Coverage ----
  describe('AutoSave (Comprehensive Coverage)', () => {
    let as;

    beforeEach(() => {
      window.EventBus = new EventBus();
      as = new AutoSave();
    });

    afterEach(() => {
      as.destroy();
    });

    it('TC-AS-007: should respond to file:modified event', (done) => {
      as.start(50);
      let saved = false;
      EventBus.on('file:save', () => { saved = true; });
      EventBus.emit('file:modified', { modified: true, panelId: 'left' });
      setTimeout(() => {
        as.stop();
        assert.ok(saved, 'Should auto-save after modified event');
        done();
      }, 120);
    });

    it('TC-AS-008: should reset modified on file:saved event', () => {
      as._modified = true;
      EventBus.emit('file:saved', { panelId: 'left' });
      assert.notOk(as._modified, 'Modified should be false after save');
    });

    it('TC-AS-009: resetTimer should restart the timer', () => {
      as.start(5000);
      assert.doesNotThrow(() => as.resetTimer());
    });

    it('TC-AS-010: start with 0 interval should still enable', () => {
      as.start(0);
      assert.ok(as.isEnabled());
      as.stop();
    });

    it('TC-AS-011: multiple start/stop cycles should work', () => {
      as.start(1000);
      assert.ok(as.isEnabled());
      as.stop();
      assert.notOk(as.isEnabled());
      as.start(2000);
      assert.ok(as.isEnabled());
      as.stop();
      assert.notOk(as.isEnabled());
    });
  });

  // ---- Toast: Coverage ----
  describe('Toast', () => {
    let toast, container;

    beforeEach(() => {
      container = document.getElementById('test-toast-container');
      container.innerHTML = '';
      toast = new Toast(container);
    });

    it('TC-TO-001: should show a toast message', () => {
      toast.show('Test message', 'info', 0);
      assert.equal(container.children.length, 1);
    });

    it('TC-TO-002: should show correct icon for success type', () => {
      toast.show('Success', 'success', 0);
      const icon = container.querySelector('.toast-icon');
      assert.ok(icon.textContent.includes('\u2713'));
    });

    it('TC-TO-003: should show correct icon for error type', () => {
      toast.show('Error', 'error', 0);
      const icon = container.querySelector('.toast-icon');
      assert.ok(icon.textContent.includes('\u2717'));
    });

    it('TC-TO-004: should show correct icon for warning type', () => {
      toast.show('Warning', 'warning', 0);
      const icon = container.querySelector('.toast-icon');
      assert.ok(icon.textContent.includes('\u26A0'));
    });

    it('TC-TO-005: should escape HTML in message', () => {
      toast.show('<script>alert("xss")</script>', 'info', 0);
      const msg = container.querySelector('.toast-message');
      assert.ok(!msg.innerHTML.includes('<script>'), 'Should escape script tags');
      assert.ok(msg.textContent.includes('<script>'));
    });

    it('TC-TO-006: clearAll should remove all toasts', () => {
      toast.show('One', 'info', 0);
      toast.show('Two', 'success', 0);
      toast.show('Three', 'error', 0);
      assert.equal(container.children.length, 3);
      toast.clearAll();
      assert.equal(container.children.length, 0);
    });

    it('TC-TO-007: should auto-remove after duration', (done) => {
      toast.show('Auto remove', 'info', 50);
      assert.equal(container.children.length, 1);
      setTimeout(() => {
        // After duration + removal animation (300ms)
        setTimeout(() => {
          assert.equal(container.children.length, 0, 'Toast should be auto-removed');
          done();
        }, 400);
      }, 100);
    });

    it('TC-TO-008: should not throw when container is null', () => {
      const nullToast = new Toast(null);
      assert.doesNotThrow(() => nullToast.show('test'));
    });

    it('TC-TO-009: dismiss button should remove toast', () => {
      toast.show('Dismiss me', 'info', 0);
      const dismissBtn = container.querySelector('.toast-dismiss');
      assert.ok(dismissBtn);
      dismissBtn.click();
      // After animation delay
      setTimeout(() => {
        // Toast should be gone or in exit state
      }, 400);
    });
  });

  // ---- Utils: Comprehensive Coverage ----
  describe('Utils (Comprehensive Coverage)', () => {
    it('TC-UT-007: clamp with value at exact min', () => {
      assert.equal(Utils.clamp(0, 0, 10), 0);
    });

    it('TC-UT-008: clamp with value at exact max', () => {
      assert.equal(Utils.clamp(10, 0, 10), 10);
    });

    it('TC-UT-009: escapeHtml should escape ampersand', () => {
      assert.equal(Utils.escapeHtml('a&b'), 'a&amp;b');
    });

    it('TC-UT-010: escapeHtml should escape single quotes', () => {
      assert.equal(Utils.escapeHtml("it's"), "it&#039;s");
    });

    it('TC-UT-011: escapeHtml with no special chars', () => {
      assert.equal(Utils.escapeHtml('hello world'), 'hello world');
    });

    it('TC-UT-012: escapeHtml with empty string', () => {
      assert.equal(Utils.escapeHtml(''), '');
    });

    it('TC-UT-013: escapeRegex with all special chars', () => {
      const special = '.*+?^${}()|[]\\';
      const escaped = Utils.escapeRegex(special);
      assert.ok(escaped.includes('\\'));
      // Verify escaped version works as regex
      const regex = new RegExp(escaped);
      assert.ok(regex.test(special));
    });

    it('TC-UT-014: escapeRegex with normal string', () => {
      assert.equal(Utils.escapeRegex('hello'), 'hello');
    });

    it('TC-UT-015: formatFileSize for various sizes', () => {
      assert.equal(Utils.formatFileSize(0), '0 B');
      assert.equal(Utils.formatFileSize(512), '512 B');
      assert.equal(Utils.formatFileSize(1024), '1 KB');
      assert.equal(Utils.formatFileSize(1536), '1.5 KB');
      assert.equal(Utils.formatFileSize(1048576), '1 MB');
      assert.equal(Utils.formatFileSize(1073741824), '1 GB');
    });

    it('TC-UT-016: debounce should use latest arguments', (done) => {
      let lastArgs = null;
      const fn = Utils.debounce((...args) => { lastArgs = args; }, 30);
      fn(1);
      fn(2);
      fn(3);
      setTimeout(() => {
        assert.deepEqual(lastArgs, [3]);
        done();
      }, 80);
    });

    it('TC-UT-017: throttle first call should execute immediately', () => {
      let count = 0;
      const fn = Utils.throttle(() => count++, 100);
      fn();
      assert.equal(count, 1, 'First call should execute immediately');
    });

    it('TC-UT-018: throttle subsequent calls should be suppressed', () => {
      let count = 0;
      const fn = Utils.throttle(() => count++, 100);
      fn();
      fn();
      fn();
      assert.equal(count, 1, 'Only first call should execute');
    });
  });

  // ---- EventBus: Extended Coverage ----
  describe('EventBus (Extended Coverage)', () => {
    it('TC-EB-007: on should return unsubscribe function', () => {
      const bus = new EventBus();
      let called = false;
      const unsub = bus.on('test', () => { called = true; });
      assert.equal(typeof unsub, 'function');
      unsub(); // unsubscribe
      bus.emit('test', {});
      assert.notOk(called, 'Should not call after unsubscribe');
    });

    it('TC-EB-008: off with non-existent event should not throw', () => {
      const bus = new EventBus();
      assert.doesNotThrow(() => bus.off('nonexistent', () => {}));
    });

    it('TC-EB-009: emit with listener that throws should not break other listeners', () => {
      const bus = new EventBus();
      let secondCalled = false;
      bus.on('test', () => { throw new Error('intentional'); });
      bus.on('test', () => { secondCalled = true; });
      bus.emit('test', {});
      assert.ok(secondCalled, 'Second listener should still run');
    });

    it('TC-EB-010: once should properly clean up', () => {
      const bus = new EventBus();
      let count = 0;
      bus.once('test', () => count++);
      bus.emit('test', {});
      bus.emit('test', {});
      bus.emit('test', {});
      assert.equal(count, 1);
    });
  });

  // ---- Edge Case: Unicode and Long Text ----
  describe('Edge Cases: Unicode and Long Text', () => {
    it('TC-EDGE-001: EditorManager with Japanese text', () => {
      const textarea = document.getElementById('test-editor-left');
      const lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      const editor = new EditorManager(textarea, lineNums, 'left');
      editor.setText('\n\n ');
      assert.equal(editor.getLineCount(), 3);
      assert.ok(editor.getText().includes(''));
      editor.destroy();
    });

    it('TC-EDGE-002: EditorManager with very long line', () => {
      const textarea = document.getElementById('test-editor-left');
      const lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      const editor = new EditorManager(textarea, lineNums, 'left');
      const longLine = 'x'.repeat(10000);
      editor.setText(longLine);
      assert.equal(editor.getLineCount(), 1);
      assert.equal(editor.getText().length, 10000);
      editor.destroy();
    });

    it('TC-EDGE-003: DiffEngine with CRLF vs LF normalization', () => {
      const diff = new DiffEngine();
      const textCRLF = 'line1\r\nline2\r\nline3';
      const textLF = 'line1\nline2\nline3';
      const result = diff.computeLineDiff(textCRLF, textLF);
      assert.ok(result.changes.every(c => c.type === 'equal'), 'CRLF and LF should be normalized');
    });

    it('TC-EDGE-004: SearchManager with Unicode search', () => {
      window.EventBus = new EventBus();
      const sm = new SearchManager();
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'Hello  World ';
      const result = sm.find('');
      assert.equal(result.total, 2);
    });

    it('TC-EDGE-005: DiffEngine with empty vs non-empty reverse', () => {
      const diff = new DiffEngine();
      const result = diff.computeLineDiff('existing content', '');
      const dels = result.changes.filter(c => c.type === 'delete');
      assert.ok(dels.length > 0, 'Should detect deletion when right is empty');
    });

    it('TC-EDGE-006: SearchManager regex with zero-length match prevention', () => {
      window.EventBus = new EventBus();
      const sm = new SearchManager();
      sm.activeEditor = document.getElementById('test-editor-left');
      sm.activeEditor.value = 'abc';
      // Zero-length regex match should not cause infinite loop
      const result = sm.find('', { useRegex: true });
      assert.equal(result.total, 0, 'Empty regex should return 0 matches');
    });

    it('TC-EDGE-007: EditorManager insertText at beginning', () => {
      const textarea = document.getElementById('test-editor-left');
      const lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      const editor = new EditorManager(textarea, lineNums, 'left');
      editor.setText('World');
      editor.insertText(0, 'Hello ');
      assert.equal(editor.getText(), 'Hello World');
      editor.destroy();
    });

    it('TC-EDGE-008: EditorManager insertText at end', () => {
      const textarea = document.getElementById('test-editor-left');
      const lineNums = document.getElementById('test-line-numbers-left');
      textarea.value = '';
      lineNums.innerHTML = '';
      window.EventBus = new EventBus();
      const editor = new EditorManager(textarea, lineNums, 'left');
      editor.setText('Hello');
      editor.insertText(5, ' World');
      assert.equal(editor.getText(), 'Hello World');
      editor.destroy();
    });
  });

  // ---- Integration: Cross-Module Coverage ----
  describe('Integration: Cross-Module Extended', () => {
    it('TC-INT-016: file:drop event should be handled by FileManager', async () => {
      window.EventBus = new EventBus();
      const fm = new FileManager();
      let fileOpened = false;
      EventBus.on('file:open', () => { fileOpened = true; });
      const file = new File(['test'], 'test.txt', { type: 'text/plain' });
      EventBus.emit('file:drop', { panelId: 'left', file });
      // Wait for async processing
      await new Promise(r => setTimeout(r, 100));
      assert.ok(fileOpened, 'file:open should be emitted via file:drop');
    });

    it('TC-INT-017: settings:change should be emittable', () => {
      window.EventBus = new EventBus();
      let received = null;
      EventBus.on('settings:change', (data) => { received = data; });
      const sm = new SettingsManager();
      sm.set('fontSize', 24);
      assert.ok(received);
      assert.equal(received.key, 'fontSize');
      assert.equal(received.value, 24);
      sm.resetToDefaults();
    });

    it('TC-INT-018: AutoSave should listen to file:modified events', () => {
      window.EventBus = new EventBus();
      const as = new AutoSave();
      as.start(5000);
      EventBus.emit('file:modified', { modified: true, panelId: 'left' });
      assert.ok(as._modified, 'AutoSave should track modified state');
      as.destroy();
    });

    it('TC-INT-019: diff:compute should be processable by SplitView', () => {
      window.EventBus = new EventBus();
      const container = document.getElementById('test-editor-container');
      const sv = new SplitView(container);
      sv._enabled = true;
      let resultEmitted = false;
      EventBus.on('diff:result', () => { resultEmitted = true; });
      // Trigger diff compute directly
      EventBus.emit('diff:compute', { textLeft: 'a\nb', textRight: 'a\nc' });
      // Debounced - wait for it
      setTimeout(() => {
        // Result will be emitted after 150ms debounce
      }, 200);
    });

    it('TC-INT-020: theme:change event propagation', () => {
      window.EventBus = new EventBus();
      const tm = new ThemeManager();
      let received = null;
      EventBus.on('theme:change', (data) => { received = data; });
      tm.setTheme('dark');
      assert.ok(received);
      assert.equal(received.theme, 'dark');
      tm.setTheme('light');
      tm.destroy();
    });
  });

  // ============================================================
  // Run tests on load
  // ============================================================
  window.addEventListener('load', () => {
    // Small delay to ensure DOM is fully ready
    setTimeout(() => {
      window._runAllTests().then((results) => {
        console.log(`Tests complete: ${results.pass}/${results.total} passed (${Math.round(results.pass/results.total*100)}%)`);
      });
    }, 100);
  });
  </script>
</body>
</html>
